import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_nfc_kit/flutter_nfc_kit.dart';
import 'package:pointycastle/api.dart';
import 'package:pointycastle/asymmetric/api.dart';
import 'package:pointycastle/asymmetric/api.dart' as pc;
import 'package:pointycastle/asymmetric/rsa.dart';
import 'package:testpos/models/transaction_log_model.dart';
import 'package:testpos/presentation/main_navigation.dart';
import 'package:testpos/presentation/pin_entry_page.dart';
import 'package:testpos/presentation/transaction_detail_page.dart';
import 'package:testpos/presentation/transaction_history_page.dart';
import 'package:testpos/presentation/transaction_summary_page.dart';
import 'package:testpos/secure_storage_helper.dart';
import 'package:testpos/transaction_storage.dart';
import 'core/tlv_parser.dart';
import 'core/hex.dart';
import 'data/nfc/apdu_commands.dart';
import 'package:encrypt/encrypt.dart' as encrypt;
import 'presentation/nfc_waiting_page.dart';
import 'package:pointycastle/asymmetric/rsa.dart'; // ‚úÖ Pour RSAEngine et RSAPublicKey
import 'package:pointycastle/api.dart' as pc; // ‚úÖ Pour PublicKeyParameter
import 'package:convert/convert.dart';

void main() {
  runApp(
    MaterialApp(
      title: 'SoftPOS',
      debugShowCheckedModeBanner: false,
      home:
          const MainNavigation(), // C'est ici qu'on charge le menu principal avec onglets
      routes: {
        '/nfcWaiting': (context) => const NfcWaitingPage(initialAmount: ''),
        '/transactionSummary': (context) => const TransactionSummaryPage(),
        '/transactionDetail': (context) => const TransactionDetailPage(),
        '/transactionHistory':
            (context) => const TransactionHistoryPage(), // si besoin s√©par√©ment
      },
    ),
  );
}

class GenerateACResult {
  final String ac;
  final String atc;
  final String cid;
  final List<int> rawResponse;

  GenerateACResult({
    required this.ac,
    required this.atc,
    required this.cid,
    required this.rawResponse,
  });
}

class HomeScreen extends StatefulWidget {
  //un √©cran (une page) qui peut √©voluer dans le temps (c‚Äôest un StatefulWidget, donc il a un State associ√©).
  final String?
  initialAmount; //un champ (attribut) de ta classe HomeScreen, appel√© initialAmount.C‚Äôest une valeur facultative (String?) qui repr√©sente le montant √† encaisser
  const HomeScreen({
    super.key,
    this.initialAmount,
  }); //le constructeur de la page :super.key est un param√®tre utile pour Flutter (optimisations internes).this.initialAmount permet de passer directement une valeur √† initialAmount
  @override
  State<HomeScreen> createState() => _HomeScreenState(); // Tu dis que le "state" (l'√©tat) de cette page sera g√©r√© par une autre classe : _HomeScreenState
}

class _HomeScreenState extends State<HomeScreen> {
  String pan = ''; // PAN (Primary Account Number)
  String expiration = ''; // Date d'expiration
  String name = ''; // Nom du titulaire
  String ac = ''; // Cryptogramme AC
  String atc = ''; // Application Transaction Counter
  String cid = ''; // CID (Cryptogram Information Data)
  String result = ''; // R√©sultat de l'op√©ration
  String amount = ''; // Montant de la transaction
  String transactionReference = ''; // R√©f√©rence de la transaction
  String authorizationCode = ''; // Code d'autorisation
  bool isLoading = false; // Indicateur de chargement
  TextEditingController amountController =
      TextEditingController(); // Contr√¥leur pour le montant
  final int floorLimit = 100000; // Montant en centimes : ici 1000.00 DA
  String cardCountryCode = '000'; // Valeur par d√©faut si 9F1A n'est pas trouv√©
  late Uint8List generatedArpc;
  late String authorizationResponseCode;

  // ‚û°Ô∏è Fonction pour d√©crypter avec la cl√© publique CA
  Uint8List decryptWithCAPublicKey(Uint8List signature) {
    final modulus = BigInt.parse(
      'C2FA4312E3B5174838241FAC87D9A46B984BC45A88A71979823852D3F6C65708C78BC742C0595108C6679EF52BEC7AE4D3D13F776876430982AAA38125629CF9CE22029C65CA4F4C5C9F34D8A2CF704846937A2C7695D58324BDF3092521511FE29FD8872FC7A1E2C76A82B6DD691DA4468B1331793800635F7D622723987CEA6AD6DA0AB489D0637A3663DF0E5364662119CE2CF76C96894D623E0BF36CEED3330C84EC7353DA1AD064C8095F162841',
      radix: 16,
    );
    final exponent = BigInt.parse('03', radix: 16);

    final publicKey = RSAPublicKey(modulus, exponent);

    final decryptor =
        RSAEngine()..init(false, PublicKeyParameter<RSAPublicKey>(publicKey));

    return decryptor.process(signature);
  }

  // ‚û°Ô∏è Fonction pour extraire le 9F4B
  Uint8List extract9F4B(Uint8List response) {
    int index = 0;
    while (index < response.length - 2) {
      if (response[index] == 0x9F && response[index + 1] == 0x4B) {
        int length = response[index + 2];
        return response.sublist(index + 3, index + 3 + length);
      }
      index++;
    }
    throw Exception('9F4B not found in the response');
  }

  List<int> generateUnpredictableNumber() {
    final random = DateTime.now().millisecondsSinceEpoch;
    return [
      (random >> 24) & 0xFF,
      (random >> 16) & 0xFF,
      (random >> 8) & 0xFF,
      random & 0xFF,
    ];
  }

  // üóÇÔ∏è Table CAPK (cl√© publique par RID et index)
  final Map<String, List<Map<String, String>>> capkTable = {
    'A000000003': [
      // Visa RID
      {
        'index': '92', // Valeur de 9F22 fournie par la carte
        'modulus': //la grande cl√© (cl√© RSA, nombre premier).
            'A38BCE78947B3F8D4EF4F93AA76B1F6B6E6C1B25B2B9E9CFBDE3C1A0D198E2113A336875C2D16A1F42ADFC23A28196A731E8AAB1881E12E1851B03F3E9FC1045',
        'exponent':
            '03', //petit nombre, souvent 03 ou 65537 (valeurs classiques pour RSA).
      },
      // ajouter d'autres cl√©s ici (ex : Mastercard, Amex)
    ],
    'A000000004': [
      // Mastercard RID
      {
        'index': '92',
        'modulus':
            'A8D3B2C158BF557F6A65A7D54D6B595F1AA28F1BC18985D358B47855A6B6A545F4C9818DC8D2E1152A3B516D23A1F19D225D5B9E03A61D17ECA02F4AC2B45A465',
        'exponent': '03',
      },
    ],
  };
  /*Quand on utilises SDA (Static Data Authentication) ou DDA/CDA (Dynamic Data Authentication), il faut :

      V√©rifier que la signature fournie par la carte est authentique.

      Pour √ßa, il faut une cl√© publique du Certificate Authority (CA).

      Ces cl√©s sont stock√©es dans ton terminal (ici dans capkTable) et sont identifi√©es par :

      Le RID = Registered Application Provider Identifier (exemple : 'A000000003' = Visa).

      Le index = Index de la cl√© utilis√©e par la carte (ex. '92' dans 9F22). */

  late encrypt.Key
  aesKey; // D√©claration des variables pour la cl√© AES et l‚ÄôIV (pas initialis√©es tout de suite).
  late encrypt.IV aesIv;

  List<TransactionLog> transactionLogs =
      []; // Historique local des transactions
  /*Chaque TransactionLog contient :

      pan, expiration, atc, ac, cid, etc.

      ‚û°Ô∏è Et certains champs (ac, atc, cid) sont chiffr√©s gr√¢ce √† ta cl√© AES.

      */

  /// Demande √† l'utilisateur de saisir son PIN via l'√©cran `PinEntryPage`.
  ///  C'est utilis√© pour la v√©rification du porteur de la carte (CVM : Cardholder Verification Method).
  /// Si le PIN est correct (longueur ‚â• 4), la fonction continue.
  /// Sinon, elle arr√™te la transaction avec une exception ("CVM √©chou√©").
  /// Demande √† l'utilisateur de saisir son PIN.
  /// Retourne le PIN si saisi correctement, sinon lance une exception.
  /// Demande √† l'utilisateur de saisir son PIN.
  /// Retourne le PIN si saisi correctement, sinon lance une exception.
  Future<String> _demanderPin() async {
    final pin = await Navigator.push<String>(
      context,
      MaterialPageRoute(builder: (_) => const PinEntryPage()),
    );

    if (!mounted) return ''; // S√©curit√© : si la page a √©t√© d√©mont√©e entre-temps

    if (pin == null || pin.length < 4) {
      setState(() => result = '‚ùå PIN incorrect ou annul√©');
      throw Exception('CVM √©chou√©'); // Arr√™te la transaction
    }

    print('‚úÖ PIN saisi : $pin');
    return pin; // üî• Le PIN est maintenant bien retourn√© √† l‚Äôappelant !
  }

  Future<void> sendOfflinePlaintextPin(String pin) async {
    if (pin.isEmpty) {
      throw Exception('PIN vide, impossible d‚Äôenvoyer √† la carte');
    }

    // Pr√©pare le PIN Block (format 2)
    // Exemple : 2412 345F FFFF FFFF (24 = length 4 digits, 12 34 5F... = PIN + padding F)
    String pinBlock =
        '2${pin.length}$pin${'FFFFFFFFFFFF'.substring(0, 14 - pin.length * 2)}';

    // Envoie la commande VERIFY (0x20)
    final apdu = [
      0x00, // CLA
      0x20, // INS (VERIFY)
      0x00, // P1
      0x80, // P2 (plain text PIN)
      pinBlock.length ~/ 2, // Lc (length of PIN block)
      ..._hexToBytes(pinBlock),
    ];

    final apduHex = apdu.map((e) => e.toRadixString(16).padLeft(2, '0')).join();
    final response = await FlutterNfcKit.transceive(apduHex);

    if (!response.endsWith('9000')) {
      setState(
        () =>
            result = '‚ùå PIN refus√© par la carte : ${decodeApduError(response)}',
      );
      throw Exception('PIN refus√©');
    }

    print('‚úÖ PIN accept√© par la carte');
  }

  Future<void> sendOfflineEncryptedPin(
    String pin,
    String rid,
    String capkIndex,
  ) async {
    if (pin.isEmpty) {
      throw Exception('PIN vide, impossible de continuer');
    }

    final capk = findCapk(rid, capkIndex);
    if (capk == null) {
      throw Exception('CAPK non trouv√©e pour RID $rid et index $capkIndex');
    }

    // üëâ Formatage du PIN Block (exemple Format 0)
    String pinBlock =
        '2${pin.length}$pin${'FFFFFFFFFFFF'.substring(0, 14 - pin.length * 2)}';
    List<int> pinBlockBytes = _hexToBytes(pinBlock);

    // üëâ Chiffrement RSA avec la cl√© publique CAPK
    final encrypter = encrypt.Encrypter(
      encrypt.RSA(publicKey: capk, encoding: encrypt.RSAEncoding.PKCS1),
    );
    final encryptedPin = encrypter.encryptBytes(pinBlockBytes);

    final apdu = [
      0x00, // CLA
      0x20, // INS (VERIFY)
      0x00, // P1
      0x88, // P2 (encrypted PIN block)
      encryptedPin.bytes.length, // Lc
      ...encryptedPin.bytes,
    ];

    final apduHex = apdu.map((e) => e.toRadixString(16).padLeft(2, '0')).join();
    final response = await FlutterNfcKit.transceive(apduHex);

    if (!response.endsWith('9000')) {
      setState(
        () =>
            result =
                '‚ùå PIN chiffr√© refus√© par la carte : ${decodeApduError(response)}',
      );
      throw Exception('PIN chiffr√© refus√©');
    }

    print('‚úÖ PIN chiffr√© accept√© par la carte');
  }

  /*Cette fonction d√©cide quelle action prendre selon le CID (Cryptogram Information Data) que la carte a g√©n√©r√© et si la transaction peut se faire offline.
    C‚Äôest ce qu‚Äôon appelle le Terminal Action Analysis (TAA) dans le standard EMV. */
  String _terminalActionAnalysis(String cid, bool canGoOffline) {
    // cid : c‚Äôest le code que la carte envoie pour dire ce qu‚Äôelle veut (approbation, refus, demande online). / canGoOffline : une valeur true ou false qui indique si le terminal accepte de faire des transactions offline (en fonction de la politique de gestion du risque).
    if (cid == '40' && canGoOffline) {
      return 'APPROVED_OFFLINE'; // TC = Transaction Certificate
    } else if (cid == '80') {
      return 'DECLINED'; // AAC = Application Authentication Cryptogram
    } else if (cid == '00') {
      return 'ONLINE_REQUESTED'; // ARQC = Authorization Request
    } else {
      return 'UNKNOWN';
    }
  } //M√™me si la carte propose, c‚Äôest le terminal qui tranche selon ses r√®gles de s√©curit√©.

  // üîÑ Partie ONLINE ‚Üí √† remplacer la simulation plus tard par un vrai appel HTTP ou HSM
  /*Quand la carte demande une autorisation online (ARQC), cette fonction est cens√©e envoyer une requ√™te HTTP √† ton serveur bancaire (ou HSM) pour savoir si la transaction est accept√©e ou refus√©e.
  on utilises une simulation (pas de vrai backend encore),  pr√™t pour √™tre remplac√© par un vrai appel. */
  Future<bool> sendArqcToBackend({
    required String
    arqc, // ARQC g√©n√©r√© par la carte (Authorization Request Cryptogram)
    required String pan, // PAN complet (num√©ro de carte)
    required String
    atc, // ATC = Application Transaction Counter (compteur de transactions)
    required int amount, // Montant de la transaction
    required String pinOnline,
  }) async {
    // EXEMPLE D‚ÄôAPPEL HTTP (POST) vers ton serveur d'autorisation Envoie un POST HTTP vers ton backend.Avec un JSON qui contient les infos n√©cessaires
    /*
  final response = await http.post(
    Uri.parse('https://your-backend.com/authorize'),
    headers: {'Content-Type': 'application/json'},
    body: jsonEncode({
      'arqc': arqc,
      'pan': pan,
      'atc': atc,
      'amount': amount,
      'pin': pinOnline,
    }),
  );
   //Traitement de la r√©ponse
  if (response.statusCode == 200) {Si le serveur r√©pond avec 200 OK 
    final data = jsonDecode(response.body);
    return data['authorized'] == true; //Il regarde dans la r√©ponse JSON si authorized == true
  } else {
    throw Exception('Erreur serveur ou r√©seau : ${response.statusCode}'); // il lance une exception ‚Üí √©chec r√©seau ou serveur
  }
  */

    // ‚ö†Ô∏è TEMPORAIRE (simulation actuelle) : a Supprime
    await Future.delayed(const Duration(seconds: 2));

    // ‚û°Ô∏è G√©n√®re l'ARPC fictif √† partir de l'ARQC
    final arqcBytes = _hexToBytes(arqc);
    generatedArpc = Uint8List.fromList(arqcBytes.take(8).toList());

    // ‚û°Ô∏è Stocke un code d'autorisation (00 = accept√©)
    authorizationResponseCode = '00'; // tu peux mettre '05' si refus√©

    print('‚úÖ ARQC envoy√© avec PIN online : $pinOnline');
    return true;
  }

  void decisionTerminale(String cidHex) {
    final cid = int.parse(cidHex, radix: 16);

    if (cid == 0x40) {
      print('‚úÖ Transaction accept√©e offline (TC)');
      // Tu peux afficher "Paiement accept√©" directement
    } else if (cid == 0x80) {
      print('üì° Transaction √† envoyer pour autorisation online (ARQC)');
      // Normalement ici, tu dois appeler un serveur bancaire
      // (tu peux simuler une autorisation OK dans ton cas pour continuer)
    } else if (cid == 0x00) {
      print('‚ùå Transaction refus√©e (AAC)');
      // Afficher √©chec paiement
    } else {
      print('‚ö†Ô∏è CID inconnu : $cid');
      // Comportement par d√©faut : refuser
    }
  }

  /*C‚Äôest la fonction qui g√©n√®re le Application Cryptogram (AC), √©tape essentielle dans le process EMV.

    L‚ÄôAC peut √™tre :

    TC (Transaction Certificate) si la transaction est approuv√©e offline,

    AAC (Application Authentication Cryptogram) si la carte refuse,

    ARQC (Authorization Request Cryptogram) si la carte demande l‚Äôautorisation en ligne (backend / HSM).

    */

  Future<Object?> generateAcFixed(
    String taaDecision,
    List<TLV> recordTlvs,
    String amount,
  ) async {
    try {
      TLV? cdol1Tlv;
      for (final record in recordTlvs) {
        cdol1Tlv = TLVParser.findTlvRecursive([record], 0x8C);
        if (cdol1Tlv != null) {
          print(
            '‚úÖ CDOL1 trouv√© : ${cdol1Tlv.value.map((e) => e.toRadixString(16).padLeft(2, '0')).join()}',
          );
          break;
        }
      }

      if (cdol1Tlv == null) {
        print('‚ùå Aucun CDOL1 trouv√© dans les records.');
        return [];
      }
      final r = recordTlvs;
      final cdol1 = cdol1Tlv.value;
      List<int> cdolData = [];
      int idx = 0;

      while (idx < cdol1.length) {
        int firstByte = cdol1[idx];
        String tag = '';
        if ((firstByte & 0x1F) == 0x1F) {
          tag =
              cdol1[idx].toRadixString(16).padLeft(2, '0') +
              cdol1[idx + 1].toRadixString(16).padLeft(2, '0');
          idx += 2;
        } else {
          tag = cdol1[idx].toRadixString(16).padLeft(2, '0');
          idx += 1;
        }
        tag = tag.toUpperCase();

        final length = cdol1[idx];
        idx += 1;

        print('üîé Tag trouv√© : $tag longueur : $length');

        switch (tag) {
          case '9F02': // Amount Authorized
            int transactionAmount =
                ((double.tryParse(amount) ?? 0) * 100).toInt();
            cdolData.addAll(
              _hexToBytes(
                transactionAmount.toRadixString(16).padLeft(length * 2, '0'),
              ),
            );
            break;
          case '9F03': // Amount Other
            cdolData.addAll(List.filled(length, 0x00));
            break;
          case '9F1A': // Terminal Country Code
            cdolData.addAll(
              _hexToBytes('0564'.padLeft(length * 2, '0')),
            ); // Alg√©rie
            break;
          case '95': // Terminal Verification Results
            cdolData.addAll(_hexToBytes('8000048000'.padLeft(length * 2, '0')));
            break;
          case '5F2A': // Transaction Currency Code
            cdolData.addAll(
              _hexToBytes('0121'.padLeft(length * 2, '0')),
            ); // Dinar
            break;
          case '9A': // Transaction Date
            cdolData.addAll(_hexToBytes('250507')); // YYMMDD
            break;
          case '9C': // Transaction Type
            cdolData.add(0x00); // Purchase
            break;
          case '9F37': // Unpredictable Number
            cdolData.addAll(_hexToBytes('B9467AAA')); // Number fixe
            break;
          case '9F35': // Terminal Type
            cdolData.add(0x22);
            break;
          case '9F34': // CVM Results
            cdolData.addAll(_hexToBytes('420300'.padLeft(length * 2, '0')));
            break;
          default:
            print('‚ÑπÔ∏è Tag inconnu $tag ‚Üí remplissage avec 00');
            cdolData.addAll(List.filled(length, 0x00));
            break;
        }
      }

      final acType = (taaDecision == 'APPROVED_OFFLINE') ? 0x40 : 0x80;
      final lc = cdolData.length;
      final generateAcCommand = [
        0x80,
        0xAE,
        acType,
        0x00,
        lc,
        ...cdolData,
        0x00,
      ];

      final generateAcHex =
          generateAcCommand
              .map((e) => e.toRadixString(16).padLeft(2, '0'))
              .join();
      print('üì§ Envoi Generate AC : $generateAcHex');

      final responseHex = await FlutterNfcKit.transceive(generateAcHex);
      print('üì• R√©ponse Generate AC : $responseHex');
      final responseBytesList = _hexToBytes(responseHex);
      final responseBytes = Uint8List.fromList(responseBytesList);
      final generateAcTlvs = TLVParser.parse(responseBytes);

      // ‚ú® Correction ici ‚ú®
      Map<String, String> extractedAuthData = {};

      TLV? template77 = TLVParser.findTlvRecursive(generateAcTlvs, 0x77);
      if (template77 != null) {
        final subTlvs = TLVParser.parse(template77.value);
        for (final tlv in subTlvs) {
          if (tlv.tag == 0x9F26) {
            // AC
            extractedAuthData['ac'] =
                tlv.value
                    .map((b) => b.toRadixString(16).padLeft(2, '0'))
                    .join();
            print('‚úÖ AC trouv√© : ${extractedAuthData['ac']}');
          }
          if (tlv.tag == 0x9F36) {
            // ATC
            extractedAuthData['atc'] =
                tlv.value
                    .map((b) => b.toRadixString(16).padLeft(2, '0'))
                    .join();
            print('‚úÖ ATC trouv√© : ${extractedAuthData['atc']}');
          }
          if (tlv.tag == 0x9F27) {
            // CID
            extractedAuthData['cid'] =
                tlv.value
                    .map((b) => b.toRadixString(16).padLeft(2, '0'))
                    .join();
            print('‚úÖ CID trouv√© : ${extractedAuthData['cid']}');
          }
        }
      } else {
        print('‚ùå Pas de template 77 trouv√© dans la r√©ponse Generate AC');
      }

      bool hasAc =
          extractedAuthData.containsKey('ac') &&
          extractedAuthData['ac']!.isNotEmpty;
      bool hasAtc =
          extractedAuthData.containsKey('atc') &&
          extractedAuthData['atc']!.isNotEmpty;
      bool hasCid =
          extractedAuthData.containsKey('cid') &&
          extractedAuthData['cid']!.isNotEmpty;

      if (hasAc && hasAtc && hasCid) {
        print('‚úÖ Tous les √©l√©ments n√©cessaires ont √©t√© extraits.');
      } else {
        print('‚ùå Donn√©es manquantes dans Generate AC.');
      }
      if (hasCid) {
        final cidHex = extractedAuthData['cid']!;
        if (cidHex == '40') {
          // ‚úÖ Transaction accept√©e offline
          await secondGenerateAc(authorized: true, recordTlvs: r);
        } else if (cidHex == '00') {
          // üì° Transaction demande une autorisation online
          final pinOnline =
              await _demanderPin(); // (demander un PIN online √©ventuellement)

          final isAuthorized = await sendArqcToBackend(
            arqc: extractedAuthData['ac']!,
            pan: pan,
            atc: extractedAuthData['atc']!,
            amount: ((double.tryParse(amount) ?? 0) * 100).toInt(),
            pinOnline: pinOnline,
          );

          await secondGenerateAc(authorized: isAuthorized, recordTlvs: r);
        } else if (cidHex == '80') {
          // ‚ùå Transaction refus√©e offline
          await secondGenerateAc(authorized: false, recordTlvs: r);
        } else {
          // CID inconnu, refuser
          await secondGenerateAc(authorized: false, recordTlvs: r);
        }
      }

      if (hasAc && hasAtc && hasCid) {
        return GenerateACResult(
          ac: extractedAuthData['ac']!,
          atc: extractedAuthData['atc']!,
          cid: extractedAuthData['cid']!,
          rawResponse: _hexToBytes(responseHex),
        );
      } else {
        return null; // Tu peux aussi lancer une exception si tu pr√©f√®res
      }
    } catch (e) {
      print('‚ùå Erreur Generate AC : $e');
      return [];
    }
  }

  /*La fonction secondGenerateAc envoie la deuxi√®me commande GENERATE AC √† la carte bancaire pour finaliser la transaction, apr√®s avoir re√ßu la r√©ponse de la banque (autoris√©e ou refus√©e).

    Dans EMV :

    1er GENERATE AC : Demande l‚ÄôARQC (pour online) ou g√©n√®re le TC (offline).

    2nd GENERATE AC : Confirme le r√©sultat (accept√© ou refus√©) aupr√®s de la carte. */
  Future<void> secondGenerateAc({
    required bool authorized,
    List<TLV>? recordTlvs,
  }) async {
    try {
      final acType = authorized ? 0x40 : 0x80;

      List<int> cdol2Data = [];

      TLV? cdol2Tlv;
      if (recordTlvs != null) {
        for (final record in recordTlvs) {
          cdol2Tlv = TLVParser.findTlvRecursive([record], 0x8D);
          if (cdol2Tlv != null) {
            print('‚úÖ CDOL2 trouv√© pour second GENERATE AC.');
            break;
          }
        }
      }

      if (cdol2Tlv != null) {
        final cdol2 = cdol2Tlv.value;
        int idx = 0;
        while (idx < cdol2.length) {
          int firstByte = cdol2[idx];
          String tag = '';
          if ((firstByte & 0x1F) == 0x1F) {
            tag =
                cdol2[idx].toRadixString(16).padLeft(2, '0') +
                cdol2[idx + 1].toRadixString(16).padLeft(2, '0');
            idx += 2;
          } else {
            tag = cdol2[idx].toRadixString(16).padLeft(2, '0');
            idx += 1;
          }
          tag = tag.toUpperCase();
          final length = cdol2[idx];
          idx += 1;

          print(
            'üîé Tag CDOL2 trouv√© pour second AC : $tag, longueur : $length',
          );

          switch (tag) {
            case '91':
              cdol2Data.addAll([
                0x67,
                0x9A,
                0xEF,
                0x7F,
                0x00,
                0x82,
                0x00,
                0x00,
              ]);
              break;
            case '8A':
              cdol2Data.addAll([0x30, 0x30]); // "00" en ASCII
              break;
            case '95':
              cdol2Data.addAll([0x00, 0x00, 0x00, 0x00, 0x02]);
              break;
            case '9F37':
              cdol2Data.addAll([0x30, 0x90, 0x1B, 0x6A]);
              break;
            default:
              cdol2Data.addAll(List.filled(length, 0x00));
              break;
          }
        }
      } else {
        print('‚ÑπÔ∏è Aucun CDOL2 trouv√© ‚Üí remplissage par d√©faut.');
        cdol2Data = [
          0x67, 0x9A, 0xEF, 0x7F, 0x00, 0x82, 0x00, 0x00, // 91
          0x30, 0x30, // 8A
          0x00, 0x00, 0x00, 0x00, 0x02, // 95
          0x30, 0x90, 0x1B, 0x6A, // 9F37
        ];
      }

      // ‚úÖ Maintenant envoyer le Second GENERATE AC

      final generateAcCommand = [
        0x00, // PAS 0x80 ‚Üí mettre 0x00 au lieu de 0x80 ici !!
        0xAE,
        acType,
        0x00,
        cdol2Data.length,
        ...cdol2Data,
        0x00,
      ];

      final generateAcHex =
          generateAcCommand
              .map((e) => e.toRadixString(16).padLeft(2, '0'))
              .join();
      print('üì§ Second GENERATE AC (avec CDOL2) : $generateAcHex');

      String? responseHex;
      try {
        responseHex = await FlutterNfcKit.transceive(generateAcHex);
        print('üì• R√©ponse Second Generate AC : $responseHex');
      } catch (e) {
        print('‚ùå Erreur durant transceive : $e');
        await FlutterNfcKit.finish();
        return;
      }

      await FlutterNfcKit.finish();

      setState(() {
        result =
            authorized
                ? '‚úÖ Transaction autoris√©e apr√®s second GENERATE AC'
                : '‚ùå Transaction refus√©e apr√®s second GENERATE AC';
      });

      final log = TransactionLog(
        pan: pan,
        expiration: expiration,
        atc: atc,
        result: result,
        timestamp: DateTime.now(),
        amount: amount,
        dateTime: DateTime.now().toString(),
        status: result,
      );
      transactionLogs.add(log);
      await TransactionStorage.saveTransactions(transactionLogs);

      Navigator.pushReplacementNamed(
        context,
        '/transactionDetail',
        arguments: log,
      );
    } catch (e) {
      print('‚ùå Erreur lors du second GENERATE AC corrig√© : $e');
    }
  }

  //rouver la cl√© publique du Certificate Authority (CA), qui est utilis√©e pour v√©rifier la signature RSA (Static Data Authentication).

  RSAPublicKey? findCapk(String rid, String index) {
    final capkList =
        capkTable[rid]; // R√©cup√®re la liste des cl√©s pour le RID donn√©. dentifie le fournisseur (Visa, Mastercard, etc.)
    if (capkList == null) return null; // Si pas de cl√©s ‚Üí retourne null.

    final capk = capkList.firstWhere(
      (capk) =>
          capk['index'] ==
          index, // Cherche la cl√© avec l‚Äôindex donn√©. Indique laquelle des cl√©s du CA utiliser
      orElse: () => {},
    );

    if (capk.isEmpty) return null; // Si pas trouv√© ‚Üí retourne null.

    // Construit la cl√© RSA publique avec le modulus et l‚Äôexponent.
    return RSAPublicKey(
      BigInt.parse(capk['modulus']!, radix: 16), //Partie de la cl√© RSA
      BigInt.parse(capk['exponent']!, radix: 16), //Autre partie de la cl√© RSA
    );
  }

  bool _verifySDASignature(
    Uint8List signature,
    Uint8List staticData,
    String aidHex,
    List<TLV> aidResponseTlvs,
  ) {
    try {
      final String rid = aidHex.substring(0, 10);

      final capkTlv =
          TLVParser.findTlvRecursive(aidResponseTlvs, 0x9F22) ??
          TLV(0x00, Uint8List(0));
      final capkIndex =
          capkTlv.value.map((b) => b.toRadixString(16).padLeft(2, '0')).join();

      final capk = findCapk(rid, capkIndex);
      if (capk == null) {
        print('‚ùå CAPK introuvable pour RID $rid avec index $capkIndex');
        return false;
      }

      final encrypter = encrypt.Encrypter(
        encrypt.RSA(publicKey: capk, encoding: encrypt.RSAEncoding.PKCS1),
      );

      final decrypted = encrypter.decryptBytes(encrypt.Encrypted(signature));

      final decryptedStaticData = Uint8List.fromList(
        decrypted.sublist(decrypted.length - staticData.length),
      );

      return _areUint8ListsEqual(decryptedStaticData, staticData);
    } catch (e) {
      print('‚ùå Erreur lors de la v√©rification SDA : $e');
      return false;
    }
  }

  bool _areUint8ListsEqual(Uint8List a, Uint8List b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }

  // üìò √âtapes 1 √† 13 : Processus EMV complet
  void _startEMVSession({required bool skipReset}) async {
    //D√©marrage de la transaction
    // ‚úÖ √âtape 0 : V√©rifie si le montant est valide
    if (!_isValidAmount(amount)) {
      //v√©rifies si l'utilisateur a bien entr√© un montant correct (pas vide, pas n√©gatif)
      setState(() {
        result = ' Montant invalide. Veuillez entrer un nombre valide.';
      });
      return;
    }

    // ‚úÖ √âtape 1 : V√©rifie si le NFC est disponible
    final availability = await FlutterNfcKit.nfcAvailability;
    if (availability != NFCAvailability.available) {
      setState(() {
        result = '‚ùå NFC non disponible : $availability';
      });
      return;
    }

    try {
      resetFields();
      setState(() => isLoading = true);

      // üì° √âtape 2 : Attente d'une carte NFC
      try {
        final tag = await FlutterNfcKit.poll(
          //Lance la d√©tection de la carte
          timeout: const Duration(seconds: 20),
        );
        print('‚úÖ Carte d√©tect√©e : ${tag.type}'); //r√©cup√®re le type de carte
        setState(() => result = '‚úÖ Carte d√©tect√©e : ${tag.type}');
      } catch (e) {
        print('‚ùå Erreur NFC : $e');
        setState(() => result = '‚ùå Aucune carte d√©tect√©e (timeout)');
        return;
      }

      // üì§ √âtape 2 : Envoi SELECT PPSE S√©lection de l'application de paiement Cela veut dire "S√©lectionne l'environnement de paiement".Proximity Payment System Environment 2PAY.SYS.DDF01
      final apduHex =
          ApduCommands
              .selectPPSE //Cela  renvoie l‚ÄôAID (Application Identifier), qui identifie le type de carte (Visa, Mastercard‚Ä¶).
              .map(
                (e) => e.toRadixString(16).padLeft(2, '0'),
              ) //transforme chaque byte en sa version hexad√©cimale sur deux caract√®res.
              .join();
      final responseHex = await FlutterNfcKit.transceive(
        apduHex,
      ); //prend une string hexad√©cimale et Envoi de la commande via NFC et attend la reponse √Ä la fin, 9000 = statut success (OK). Sinon, √ßa peut √™tre 6A88 ‚Üí AID not found, etc.

      // üìò Gestion des erreurs APDU pour SELECT PPSE
      final decodedError = decodeApduError(
        responseHex,
      ); //va extraire les 4 derniers caract√®res (Status Word SW1 SW2). 9000 ‚Üí "Succ√®s" 6A88 ‚Üí "S√©lecteur d‚Äôapplication non trouv√©" 6700 ‚Üí "Param√®tre incorrect

      if (decodedError != 'Succ√®s') {
        setState(() => result = decodedError); // Afficher l'erreur si √©chec
        return;
      }
      // La r√©ponse du SELECT PPSE est une structure TLV
      final responseBytesList = _hexToBytes(
        responseHex,
      ); // Transforme la string hex en liste de bytes (List<int>)
      final responseBytes = Uint8List.fromList(
        responseBytesList,
      ); // Convertit en Uint8List car TLVParser.parse attend Uint8List
      final tlvs = TLVParser.parse(
        responseBytes,
      ); // Utilise ton TLVParser pour extraire les champs Tag-Length-Value
      print('coucouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu :$tlvs');

      // üîç √âtape 2b : Extraction de l'AID (TAG 4F)
      final aidTlv =
          TLVParser.findTlvRecursive(tlvs, 0x4F) ??
          TLV(0x00, Uint8List(0)); // Utilise la fonction r√©cursive

      if (aidTlv.tag != 0x4F) {
        print('coucouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu 222222222');
        return; // Si aucun AID trouv√© ‚Üí on sort directement
      }
      print('coucouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu :$aidTlv');
      final aidHex =
          aidTlv.value
              .map((b) => b.toRadixString(16).padLeft(2, '0'))
              .join(); // Transforme la valeur de l'AID en string hex lisible
      print('coucouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu :$aidHex');
      // üì§ √âtape 3 : Envoi SELECT AID
      final selectAid = ApduCommands.buildSelectAID(
        // .buildSelectAID fonction qui construit l‚ÄôAPDU SELECT AID √† partir de l‚ÄôAID r√©cup√©r√©
        // Format de la commande CLA | INS | P1 | P2 | Lc | Data (AID) | Le (00)
        aidHex,
      ); // Cela s√©lectionne l‚Äôapplication de paiement sur la carte

      final selectAidHex =
          selectAid
              .map((e) => e.toRadixString(16).padLeft(2, '0'))
              .join(); // Transforme en hexad√©cimal

      final aidResponseHex = await FlutterNfcKit.transceive(
        selectAidHex,
      ); // Envoie la commande SELECT AID via NFC
      print('coucouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu :$aidResponseHex');
      // üìò Gestion des erreurs APDU pour SELECT AID
      final decodedAidError = decodeApduError(aidResponseHex);
      if (decodedAidError != 'Succ√®s') {
        // si la carte a r√©pondu avec le code 9000 (succ√®s).√ßa affiche l‚Äôerreur et arr√™te la transaction.
        setState(() => result = decodedAidError);
        return;
      }

      // üì§ Commande : Exchange Relay Resistance
      final exchangeRelayResistanceCommand = [
        0x80, // CLA (propri√©taire)
        0x50, // INS = Exchange Relay Resistance
        0x00, // P1
        0x00, // P2
        0x02, // Lc (2 octets)
        0x80, 0x00, // Data : param√®tres relay resistance
        0x00, // Le (r√©ponse attendue)
      ];

      final exchangeRelayResistanceHex =
          exchangeRelayResistanceCommand
              .map((e) => e.toRadixString(16).padLeft(2, '0'))
              .join();

      try {
        final exchangeRelayResponse = await FlutterNfcKit.transceive(
          exchangeRelayResistanceHex,
        );
        print('üì• R√©ponse Exchange Relay Resistance : $exchangeRelayResponse');

        // üß† Tu peux m√™me checker ici si la r√©ponse finit par '9000'
        if (exchangeRelayResponse.endsWith('9000')) {
          print('‚úÖ Relay Resistance √©chang√© avec succ√®s.');
        } else {
          print('‚ö†Ô∏è R√©ponse inattendue : $exchangeRelayResponse');
          // Tu continues malgr√© tout, pas d'arr√™t ici
        }
      } catch (e) {
        print('‚ö†Ô∏è Exchange Relay Resistance non support√© (continuer) : $e');
      }

      /*qu‚Äôest-ce que le PDOL et le GPO ?
          PDOL (Processing Options Data Object List) ‚Üí C‚Äôest une liste de donn√©es que la carte attend du terminal avant de d√©marrer le traitement.

          Exemples d‚Äô√©l√©ments demand√©s dans le PDOL :

          Montant de la transaction (9F02)

          Code pays (9F1A)

          Devise (5F2A)

          Etc.

          GPO (Get Processing Options) ‚Üí C‚Äôest la commande qui d√©marre officiellement la transaction EMV apr√®s avoir fourni les infos demand√©es par la carte dans le PDOL.*/

      // üîê √âtape 4 : Traitement du PDOL (tag 9F38) et construction GPO dynamique

      // D√©code la r√©ponse de SELECT AID re√ßue juste avant
      final aidResponseBytesList = _hexToBytes(aidResponseHex);
      final aidResponseBytes = Uint8List.fromList(
        aidResponseBytesList,
      ); // Convertit en Uint8List pour TLVParser
      final aidResponseTlvs = TLVParser.parse(aidResponseBytes);
      print('coucouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu :$aidResponseTlvs');
      // Lecture du PDOL dans la r√©ponse
      String? pdolHex;
      final pdolTlv = TLVParser.findTlvRecursive(
        aidResponseTlvs,
        0x9F38,
      ); // Recherche du tag 9F38 r√©cursivement
      print('coucouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu PDOLE:$pdolTlv');
      if (pdolTlv != null) {
        pdolHex = Hex.encode(pdolTlv.value);
      }

      // Construction du GPO si le PDOL est pr√©sent
      List<int> gpoCommand;
      if (pdolHex != null && pdolHex.isNotEmpty) {
        final pdolBytes = _hexToBytes(pdolHex); // Transformation en bytes
        List<int> pdolData = [];
        int idx = 0;

        while (idx < pdolBytes.length) {
          // Ici, on parcourt les √©l√©ments du PDOL : Chaque entr√©e = Tag (2 octets) + Length (1 octet)
          final tag =
              pdolBytes[idx].toRadixString(16).padLeft(2, '0') +
              pdolBytes[idx + 1]
                  .toRadixString(16)
                  .padLeft(2, '0'); // Tag (2 octets)
          final length = pdolBytes[idx + 2]; // Length (1 octet)
          idx += 3;

          if (tag == '9F02') {
            // Montant de la transaction
            int transactionAmount =
                ((double.tryParse(amount) ?? 0) * 100).toInt();

            final amountHex = transactionAmount
                .toRadixString(16)
                .padLeft(length * 2, '0');
            pdolData.addAll(
              _hexToBytes(amountHex),
            ); // Montant converti en hex et rempli
          } else {
            pdolData.addAll(
              List.filled(length, 0x00),
            ); // Si ce n‚Äôest pas le montant ‚Üí on met des z√©ros (0x00)
          }
        }

        //Quand le PDOL est pr√©sent
        final dolWithTag =
            [0x83, pdolData.length] +
            pdolData; //83 = tag du GPO template.Le reste : la taille + les donn√©es.
        gpoCommand = [
          0x80, // CLA (class of instruction)
          0xA8, // INS (instruction) ‚Üí GET PROCESSING OPTIONS
          0x00, // P1
          0x00, // P2
          dolWithTag
              .length, // Lc = longueur des donn√©es suivantes (PDOL rempli)
          ...dolWithTag, // Les donn√©es demand√©es par le PDOL (ex : montant)
          0x00, // Le (longueur de r√©ponse attendue)
        ];
      } else {
        gpoCommand = [
          0x80,
          0xA8,
          0x00,
          0x00,
          0x02,
          0x83,
          0x00,
          0x00,
        ]; //Si PAS de PDOL (la carte n‚Äôa rien demand√©)
      }

      /*‚ö†Ô∏è Ne pas envoyer les donn√©es attendues par la carte ‚Üí la transaction peut √™tre rejet√©e (non-respect du PDOL).

        Si on envoies une commande sans respecter le PDOL, certaines cartes (Visa, Mastercard) peuvent r√©pondre avec une erreur comme 6A80 (data incorrecte).

        Si il n‚Äôy a pas de PDOL, la carte accepte la version courte sans souci.*/

      // Construction de la commande GPO en hexad√©cimal
      final gpoHexStr =
          gpoCommand
              .map((e) => e.toRadixString(16).padLeft(2, '0'))
              .join(); // Convertit la commande GPO en string hexad√©cimale

      // Envoi de la commande GPO via NFC
      final gpoResponseHex = await FlutterNfcKit.transceive(gpoHexStr);
      print(
        'coucouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu GPOOOOOOOOOREPONSE:$gpoResponseHex',
      );
      // Transformation de la r√©ponse GPO en bytes
      final gpoResponseBytesList = _hexToBytes(gpoResponseHex);
      final gpoResponseBytes = Uint8List.fromList(
        gpoResponseBytesList,
      ); // Convertit en Uint8List car TLVParser.parse attend Uint8List

      // Utilise ton TLVParser pour extraire les champs Tag-Length-Value
      final gpoTlvs = TLVParser.parse(gpoResponseBytes);
      print(
        'coucouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu GPOOOOOOOOOOOTTLVVV :$gpoTlvs',
      );
      // üß† √âtape 5 : Lire l'AFL (TAG 94)
      /*Juste avant, on a envoy√© la commande GPO (Get Processing Options) √† la carte.
       La r√©ponse de la carte contient plusieurs informations importantes, notamment l‚ÄôAFL (Application File Locator), qui est le plan de lecture des enregistrements. L‚ÄôAFL d√©crit quels enregistrements il faut lire sur la carte, et o√π ils se trouvent.
      Parcours de l‚ÄôAFL
      L‚ÄôAFL (tag 94) te dit o√π aller lire dans la carte, avec‚ÄØ:

      SFI : identifiant du fichier (Short File Identifier),

      Record Start / End : les lignes (records) √† lire dans ce fichier.
      Il contient des groupes de 4 octets par enregistrement‚ÄØ:


      Octet	Signification
      1er octet	SFI (Short File Identifier, 5 bits) + padding
      2√®me octet	Premier record √† lire
      3√®me octet	Dernier record √† lire
      4√®me octet	Nombre d‚Äôoccurrences (non utilis√© dans ton cas simple)
      */

      // üîç Recherche de l'AFL (Tag 94) dans la r√©ponse GPO
      final aflTlv =
          TLVParser.findTlvRecursive(gpoTlvs, 0x94) ??
          TLV(
            0x00,
            Uint8List(0),
          ); // ‚Üê Recherche r√©cursive, retourne TLV vide si pas trouv√©

      if (aflTlv.tag != 0x94) {
        return; // ‚Üê Si pas d‚ÄôAFL, on sort (car on ne peut pas continuer)
      }
      print(
        'coucouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu  AFLLLLLLLLLLTTTTTTTLVVV:$aflTlv',
      );

      // Si trouv√©, on r√©cup√®re la valeur de l‚ÄôAFL
      final afl = aflTlv.value;
      print('coucouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu  AFLLLLLLLLLL:$afl');
      // On d√©clare ici pour pouvoir l'utiliser plus tard dans le generateAC
      String fullPan = '';

      // üìñ Lecture des enregistrements
      List<TLV> readRecords = [];

      for (int i = 0; i < afl.length; i += 4) {
        final sfi = afl[i] >> 3; // Extraction du SFI (Short File Identifier)
        final recordStart = afl[i + 1]; // Premier record √† lire
        final recordEnd = afl[i + 2]; // Dernier record √† lire

        for (int record = recordStart; record <= recordEnd; record++) {
          final p1 = record; // Num√©ro du record
          final p2 =
              (sfi << 3) | 4; // Le SFI est plac√© dans les bits de poids fort
          final readRecord = [
            0x00,
            0xB2,
            p1,
            p2,
            0x00,
          ]; // Commande READ RECORD 0x00 : CLA (class byte),0xB2 : INS (instruction : READ RECORD),p1 = num√©ro du record (recordStart jusqu‚Äô√† recordEnd),p2 = (SFI << 3) | 4 : placement du SFI dans les bits de poids fort, 4 = mode ‚Äúreadrecord by SFI‚Äù.

          final apduHex =
              readRecord
                  .map((e) => e.toRadixString(16).padLeft(2, '0'))
                  .join(); //hex

          try {
            // Envoi de la commande READ RECORD
            final recordHex = await FlutterNfcKit.transceive(
              apduHex,
            ); // Envoie et r√©ception de la r√©ponse

            // Transformation de la r√©ponse en bytes
            final recordBytesList = _hexToBytes(recordHex);
            final recordBytes = Uint8List.fromList(
              recordBytesList,
            ); // Convertit en Uint8List pour TLVParser

            // Parsing TLV de la r√©ponse
            final recordTlvs = TLVParser.parse(recordBytes);
            print(
              'coucouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu  reeecorddddd:$recordTlvs',
            );
            readRecords.addAll(recordTlvs);

            for (var tlv in recordTlvs) {
              print(
                'üîç TLV trouv√© : Tag=0x${tlv.tag.toRadixString(16)}, Valeur=${Hex.encode(tlv.value)}',
              );
            }

            /// üîµ Fonction pour cr√©er ta cl√© publique √† partir du Modulus et Exponent
            pc.RSAPublicKey createPublicKey() {
              final modulus = BigInt.parse(
                'C2FA4312E3B5174838241FAC87D9A46B984BC45A88A71979823852D3F6C65708C78BC742C0595108C6679EF52BEC7AE4D3D13F776876430982AAA38125629CF9CE22029C65CA4F4C5C9F34D8A2CF704846937A2C7695D58324BDF3092521511FE29FD8872FC7A1E2C76A82B6DD691DA4468B1331793800635F7D622723987CEA6AD6DA0AB489D0637A3663DF0E5364662119CE2CF76C96894D623E0BF36CEED3330C84EC7353DA1AD064C8095F162841',
                radix: 16,
              );

              final exponent = BigInt.parse(
                '03',
                radix: 16,
              ); // Exponent classique RSA
              return pc.RSAPublicKey(modulus, exponent);
            }

            // D√©chiffrer une signature RSA
            Uint8List _decryptRSA(
              Uint8List cipherText,
              pc.RSAPublicKey publicKey,
            ) {
              final engine =
                  RSAEngine()..init(
                    false,
                    pc.PublicKeyParameter<pc.RSAPublicKey>(publicKey),
                  );
              return engine.process(cipherText);
            }

            /// üîµ Petite fonction utilitaire pour convertir des bytes en hex
            String _bytesToHex(Uint8List bytes) {
              return bytes
                  .map((b) => b.toRadixString(16).padLeft(2, '0'))
                  .join();
            }

            /// üîµ Petite fonction utilitaire pour comparer deux listes de bytes
            bool _compareBytes(List<int> a, List<int> b) {
              if (a.length != b.length) return false;
              for (int i = 0; i < a.length; i++) {
                if (a[i] != b[i]) return false;
              }
              return true;
            }

            /// üü† Fonction pour v√©rifier le r√©sultat du DDA
            void verifyDDA(
              Uint8List decryptedData,
              Uint8List unpredictableNumber,
            ) {
              if (decryptedData.isEmpty) {
                print('‚ùå Donn√©e vide, pas de signature DDA.');
                return;
              }

              print('‚úÖ Donn√©e d√©crypt√©e DDA : ${_bytesToHex(decryptedData)}');

              // V√©rification de base
              if (decryptedData[0] != 0x6A) {
                print(
                  '‚ùå Format incorrect : Le premier octet attendu est 0x6A.',
                );
                return;
              }

              // V√©rification si le UN est retrouv√©
              bool unFound = false;
              for (
                int i = 0;
                i < decryptedData.length - unpredictableNumber.length;
                i++
              ) {
                if (_compareBytes(
                  decryptedData.sublist(i, i + unpredictableNumber.length),
                  unpredictableNumber,
                )) {
                  unFound = true;
                  break;
                }
              }

              if (unFound) {
                print('‚úÖ Unpredictable Number retrouv√© dans la signature DDA.');
              } else {
                print(
                  '‚ùå Unpredictable Number PAS retrouv√© dans la signature DDA.',
                );
              }
            }

            // üîµ Fonction utilitaire pour comparer deux listes de bytes

            // üì§ Fonction compl√®te Internal Authenticate (DDA)
            Future<void> performInternalAuthenticate(
              List<TLV> aidResponseTlvs,
              String aidHex,
            ) async {
              try {
                final unpredictableNumber = _hexToBytes('B9467AAA');

                final internalAuthenticate = [
                  0x00,
                  0x88,
                  0x00,
                  0x00,
                  unpredictableNumber.length,
                  ...unpredictableNumber,
                  0x00,
                ];

                final internalAuthenticateHex =
                    internalAuthenticate
                        .map((e) => e.toRadixString(16).padLeft(2, '0'))
                        .join();

                print(
                  'üì§ Envoi Internal Authenticate : $internalAuthenticateHex',
                );

                final responseHex = await FlutterNfcKit.transceive(
                  internalAuthenticateHex,
                );
                print('üì• R√©ponse Internal Authenticate : $responseHex');

                final responseBytesList = _hexToBytes(responseHex);
                final responseBytes = Uint8List.fromList(responseBytesList);

                final parsedTlvs = TLVParser.parse(responseBytes);
                final tlv9F4B = TLVParser.findTlvRecursive(parsedTlvs, 0x9F4B);

                if (tlv9F4B == null) {
                  print('‚ùå Pas de 9F4B trouv√©.');
                  return;
                }

                final signature = tlv9F4B.value;
                print('‚úÖ Signature trouv√©e : ${Hex.encode(signature)}');

                final rid = aidHex.substring(0, 10);
                final capkTlv = TLVParser.findTlvRecursive(
                  aidResponseTlvs,
                  0x9F22,
                );
                if (capkTlv == null) {
                  print('‚ùå Pas de CAPK Index trouv√© (9F22).');
                  return;
                }
                final capkIndex =
                    capkTlv.value
                        .map((b) => b.toRadixString(16).padLeft(2, '0'))
                        .join();
                final capk = findCapk(rid, capkIndex);
                if (capk == null) {
                  print('‚ùå CAPK introuvable pour RID $rid et index $capkIndex');
                  return;
                }

                final decryptor =
                    RSAEngine()
                      ..init(false, PublicKeyParameter<RSAPublicKey>(capk));
                final decryptedData = decryptor.process(signature);

                print(
                  '‚úÖ Signature DDA d√©crypt√©e : ${Hex.encode(decryptedData)}',
                );

                bool unFound = false;
                for (
                  int i = 0;
                  i <= decryptedData.length - unpredictableNumber.length;
                  i++
                ) {
                  if (_compareBytes(
                    decryptedData.sublist(i, i + unpredictableNumber.length),
                    unpredictableNumber,
                  )) {
                    unFound = true;
                    break;
                  }
                }

                if (unFound) {
                  print('‚úÖ L‚ÄôUnpredictable Number est pr√©sent : DDA r√©ussi.');
                } else {
                  print(
                    '‚ùå L‚ÄôUnpredictable Number n\'a pas √©t√© retrouv√© : DDA √©chec.',
                  );
                }
              } catch (e) {
                print('‚ùå Erreur Internal Authenticate : $e');
              }
            }

            /* La r√©ponse de la carte contient souvent :
          - PAN (tag 5A)
          - Expiration (tag 5F24)
          - Nom du titulaire (tag 5F20)
          - Signature SDA (tag 93)
          - Autres donn√©es utiles (CVM List, ATC, AC, etc.)

          r√©cup√®res plusieurs r√©ponses au format TLV, et dans chacune il y a un 70.

          Chaque 70 contient des sous-tags diff√©rents.

          Certains 70 auront PAN, Exp,

          D'autres 70 auront 9F1A, SDA, etc.

          Donc TU DOIS analyser TOUS les 70, pas un seul.
        */

            // ‚úÖ √âtape 6 : Extraction des donn√©es

            // Initialiser les TLVs vides
            TLV panTlv = TLV(0x00, Uint8List(0));
            TLV expTlv = TLV(0x00, Uint8List(0));
            TLV countryCodeTlv = TLV(0x00, Uint8List(0));
            TLV sdaTlv = TLV(0x00, Uint8List(0));

            // Initialiser staticData
            final staticData = <int>[];

            // Parcourir les records pour chercher dans tous les 70
            for (final recordTlv in recordTlvs) {
              if (recordTlv.tag == 0x70) {
                final subTlvs = TLVParser.parse(recordTlv.value);

                // PAN
                final foundPan = TLVParser.findTlvRecursive(subTlvs, 0x5A);
                if (foundPan != null && panTlv.tag != 0x5A) {
                  panTlv = foundPan;
                  staticData.addAll(panTlv.value);
                  print('‚úÖ PAN trouv√© : ${Hex.encode(panTlv.value)}');
                }

                // Expiration
                final foundExp = TLVParser.findTlvRecursive(subTlvs, 0x5F24);
                if (foundExp != null && expTlv.tag != 0x5F24) {
                  expTlv = foundExp;
                  staticData.addAll(expTlv.value);
                  print('‚úÖ Expiration trouv√©e : ${Hex.encode(expTlv.value)}');
                }

                // CountryCode
                final foundCountry = TLVParser.findTlvRecursive(
                  subTlvs,
                  0x5f28,
                );
                if (foundCountry != null && countryCodeTlv.tag != 0x5f28) {
                  countryCodeTlv = foundCountry;
                  staticData.addAll(countryCodeTlv.value);
                  cardCountryCode =
                      countryCodeTlv.value
                          .map((b) => b.toRadixString(16).padLeft(2, '0'))
                          .join();
                  print('‚úÖ Country trouv√© : $cardCountryCode');
                }

                // SDA
                final foundSda = TLVParser.findTlvRecursive(subTlvs, 0x93);
                if (foundSda != null && foundSda.tag == 0x93) {
                  sdaTlv = foundSda;
                  print('‚úÖ SDA trouv√©e : ${Hex.encode(sdaTlv.value)}');
                } else {
                  print(
                    '‚ÑπÔ∏è Aucun SDA trouv√© : la carte utilise peut-√™tre DDA ou CDA',
                  );
                }
              }
            }

            // V√©rification de la signature SDA
            if (sdaTlv.tag == 0x93) {
              final signature = Uint8List.fromList(sdaTlv.value);

              if (staticData.isNotEmpty) {
                final isValid = _verifySDASignature(
                  signature,
                  Uint8List.fromList(staticData),
                  aidHex,
                  aidResponseTlvs,
                );

                if (!isValid) {
                  setState(() {
                    result = '‚ùå Signature SDA invalide : transaction refus√©e';
                  });
                  return;
                }
              }
            }
            if (TLVParser.findTlvRecursive(recordTlvs, 0x93) == null) {
              print('‚ÑπÔ∏è DDA non support√© par la carte, skip.');
            } else {
              await performInternalAuthenticate(aidResponseTlvs, aidHex);
            }

            // üìò √âtape 7 : Traitement de la CVM List (tag 8E)
            /*Dans EMV, la CVM (Cardholder Verification Method) permet de v√©rifier que le porteur de la carte est bien l‚Äôutilisateur l√©gitime.

                Exemples de CVM :

                PIN offline

                Signature

                Pas de CVM n√©cessaire (ex : petit montant)

                PIN online
                 La carte peut proposer plusieurs m√©thodes, class√©es par ordre de priorit√©. */

            Future<bool> checkCvmCondition(int conditionCode) async {
              final montant =
                  (double.tryParse(amount) ?? 0) *
                  100; // Montant en centimes, multipli√© par 100 pour √©viter des erreurs de pr√©cision

              switch (conditionCode) {
                case 0x00: // Toujours
                  return true;
                case 0x01: // Si le montant > seuil
                  if (montant > floorLimit) {
                    print('‚úÖ Condition CVM : Montant sup√©rieur au seuil');
                    return true;
                  }
                  break;
                case 0x02: // Si le montant <= seuil
                  if (montant <= floorLimit) {
                    print(
                      '‚úÖ Condition CVM : Montant inf√©rieur ou √©gal au seuil',
                    );
                    return true;
                  }
                  break;
                default:
                  print(
                    '‚ö†Ô∏è Condition CVM inconnue : 0x${conditionCode.toRadixString(16)}',
                  );
                  return false;
              }
              print('‚ùå Condition CVM √©chou√©e pour le montant de $montant');
              return false; // Si la condition √©choue, on renvoie false
            }

            final rid = aidHex.substring(
              0,
              10,
            ); // RID = les 10 premiers caract√®res de l'AID

            // üîç Extraction du CAPK Index (Tag 9F22)
            final capkTlv =
                TLVParser.findTlvRecursive(aidResponseTlvs, 0x9F22) ??
                TLV(0x00, Uint8List(0)); // TLV vide si pas trouv√©

            final capkIndex =
                capkTlv.value
                    .map((b) => b.toRadixString(16).padLeft(2, '0'))
                    .join(); // Convertit en string hexad√©cimale

            Future<void> sendOnlinePin(String pin) async {
              if (pin.isEmpty) {
                setState(() {
                  result = '‚ùå PIN vide, impossible de continuer';
                });
                throw Exception('PIN vide');
              }

              // Affiche un message indiquant que l'envoi du PIN en ligne est en cours.
              setState(() {
                result = 'üîÑ Envoi du PIN pour validation en ligne...';
              });

              try {
                // Simulation d'un d√©lai pour envoyer le PIN (attente pour un serveur d'autorisation)
                await Future.delayed(const Duration(seconds: 2));

                // Simule la validation du PIN en ligne (remplace avec ton appel serveur r√©el)
                bool isPinValid =
                    true; // Remplace par une validation r√©elle via serveur ou HSM

                if (isPinValid) {
                  // Si le PIN est valid√©, on passe √† l'√©tape suivante de la transaction.
                  setState(() {
                    result = '‚úÖ PIN valid√© en ligne';
                    transactionReference =
                        'TRN${DateTime.now().millisecondsSinceEpoch}';
                    authorizationCode =
                        'AUTH1234'; // Code d'autorisation simul√©
                  });
                  print('‚úÖ PIN valid√© en ligne');
                }
              } catch (e) {
                setState(() {
                  result = '‚ùå Erreur d\'envoi du PIN en ligne : $e';
                });
                print('‚ùå Erreur d\'envoi du PIN en ligne : $e');
              }
            }

            Future<bool> processCvmList(List<int> cvmList) async {
              int idx = 0;

              while (idx + 2 <= cvmList.length) {
                final cvmCode = cvmList[idx];
                final conditionCode = cvmList[idx + 1];
                idx += 2;

                final bool conditionOk = await checkCvmCondition(conditionCode);
                if (conditionOk) {
                  switch (cvmCode) {
                    case 0x00: // Toujours
                      print('‚úÖ M√©thode CVM: Pas de CVM requise');
                      return true; // Si aucune condition n'est remplie, on continue avec la transaction
                    case 0x01: // PIN offline en texte clair
                      final pin = await _demanderPin();
                      await sendOfflinePlaintextPin(pin);
                      return true;
                    case 0x02: // PIN offline chiffr√©
                      final pin = await _demanderPin();
                      await sendOfflineEncryptedPin(pin, rid, capkIndex);
                      return true;
                    case 0x03: // PIN en ligne
                      final pin = await _demanderPin();
                      await sendOnlinePin(pin); // Envoi PIN en ligne
                      return true;
                    case 0x1E: // Pas de CVM requis
                      print('‚úÖ Pas de CVM requis');
                      return true;
                    case 0x1F: // Signature
                      print('‚ö†Ô∏è Signature requise (fonction non impl√©ment√©e)');
                      return true;
                    default:
                      setState(() {
                        result =
                            '‚ùå CVM inconnu : 0x${cvmCode.toRadixString(16)}';
                      });
                      print('‚ö†Ô∏è CVM non support√© ou inconnu.');
                      return false;
                  }
                }
              }
              // Si aucune condition remplie ‚Üí refuser
              setState(
                () =>
                    result =
                        '‚ùå Aucune m√©thode CVM applicable : transaction refus√©e',
              );
              return false;
            }
            /*
            √âtape	But
            R√©cup√©rer la CVM List (Tag 8E)	Liste des m√©thodes propos√©es par la carte
            V√©rifier la condition	Montant > / ‚â§ floorLimit, Always‚Ä¶
            Appliquer la m√©thode correspondante	PIN, Signature, Aucune CVM, ou refuser
            Arr√™ter la transaction si aucune m√©thode ne fonctionne	 S√©curit√© respect√©e selon EMV */

            //R√©cup√©ration de la CVM List (tag 8E) dans les TLVs

            // üîç Recherche de la CVM List (Tag 8E) dans la r√©ponse GPO
            final cvmTlv =
                TLVParser.findTlvRecursive(recordTlvs, 0x8E) ??
                TLV(0x00, Uint8List(0));
            // TLV vide si pas trouv√©

            if (cvmTlv.tag == 0x8E) {
              final cvmList = cvmTlv.value;
              print('cvm value $cvmList ');

              // Appelle la fonction pour traiter la CVM List
              final success = await processCvmList(cvmList);

              if (!success) {
                return; // Si CVM √©chou√©e, on arr√™te ici la transaction
              }
            }

            /*Apr√®s avoir lu les enregistrements (records) via l‚ÄôAFL (Application File Locator), on obtiens un ensemble de TLVs (Tag-Length-Value). Ces TLVs contiennent :

              Les donn√©es de la carte (PAN, expiration, nom‚Ä¶).

              Les informations d‚Äôauthentification (AC, ATC, CID‚Ä¶). */

            // V√©rification si les donn√©es sensibles sont pr√©sentes et non vides avant de les crypter
            /*Si une de ces trois valeurs (AC, ATC, CID) est absente, la transaction ne peut pas continuer.
              üìå Ces donn√©es sont indispensables pour :

              Authentifier la transaction.

              V√©rifier l‚Äôint√©grit√© des calculs.

              Faire les calculs cryptographiques dans le protocole EMV. */
          } catch (_) {
            // En cas d‚Äôerreur pendant la lecture
            setState(() => result = '‚ö†Ô∏è Erreur lors de la lecture du record');
            return;
          }
        }
      }

      // üìò √âtape 8 : Analyse du CID avec d√©chiffrement
      final rawCid = decryptData(
        cid,
      ); // Le cid a √©t√© stock√© chiffr√© juste avant (pour s√©curiser les donn√©es). on  le d√©chiffres pour pouvoir l‚Äôutiliser Le CID d√©termine ce que veut faire la carte :'40' ‚Üí Transaction approuv√©e offline (TC - Transaction Certificate). '80' ‚Üí Transaction refus√©e par la carte (AAC - Application Authentication Cryptogram).'00' ‚Üí La carte demande une autorisation en ligne (ARQC - Authorization Request Cryptogram).

      final canGoOffline = _terminalRiskManagement(
        cardCountryCode,
      ); //Cette fonction d√©cide si la transaction a le droit d‚Äô√™tre offline : Si le montant est faible.Si la carte n‚Äôest pas √©trang√®re.Si le compteur de transactions offline n‚Äôa pas d√©pass√© le seuil.Si les conditions ne sont pas r√©unies ‚Üí forc√© √† passer en online.

      final taaDecision = _terminalActionAnalysis(rawCid, canGoOffline);

      /*Cette fonction croise :

      Ce que la carte demande (CID).

      Ce que le terminal autorise (via canGoOffline).


      CID	Peut offline ?	R√©sultat (TAA)
      40	Oui	            APPROVED_OFFLINE
      80	 -	             DECLINED
      00	Non            	ONLINE_REQUESTED
      Autre	-             	UNKNOWN */

      await generateAcFixed(taaDecision, readRecords, fullPan);

      /*Cela envoie la commande GENERATE AC √† la carte,
        pour confirmer la d√©cision :

        Offline : produire un TC.

        Online : produire un ARQC.

        Refus : produire un AAC.

        */
      await FlutterNfcKit.finish(); //Lib√©ration propre de la session NFC ‚Üí on termines la communication avec la carte.

      if (ac.isNotEmpty && rawCid.isNotEmpty) {
        // Si les donn√©es sont bien pr√©sentes (AC + CID)
        if (taaDecision == 'APPROVED_OFFLINE') {
          //Si APPROVED_OFFLINE Transaction termin√©e sans contacter la banque.
          setState(() => result = '‚úÖ Transaction approuv√©e offline');
        } else if (taaDecision == 'DECLINED') {
          //Si DECLINED :On arr√™te : carte elle-m√™me refuse.
          setState(() => result = '‚ùå Transaction refus√©e par la carte');
        } else if (taaDecision == 'ONLINE_REQUESTED') {
          //Si ONLINE_REQUESTED :Ici c‚Äôest une simulation de serveur d‚Äôautorisation.En vrai, il faudrait envoyer l‚ÄôARQC √† la banque (HSM ou serveur) ‚Üí retour OK ou NOK.

          setState(() => result = 'üîÑ Autorisation en ligne en cours...');
          await Future.delayed(const Duration(seconds: 2));
          transactionReference = 'TRN${DateTime.now().millisecondsSinceEpoch}';
          authorizationCode = 'AUTH1234';
          setState(
            () =>
                result =
                    '‚úÖ Autorisation accept√©e pour $amount (simulation en ligne)',
          );

          transactionLogs.add(
            //Sauvegarde de la transaction
            TransactionLog(
              pan: pan,
              expiration: expiration,
              atc: atc,
              result: result,
              timestamp: DateTime.now(),
              amount: amount,
              dateTime: DateTime.now().toString(),
              status: result,
            ),
          );
          await TransactionStorage.saveTransactions(transactionLogs);
        } else {
          //Si CID inconnu
          setState(() => result = '‚ö†Ô∏è CID inconnu : $rawCid');
        }
      } else {
        //Si des donn√©es cryptographiques sont manquantes
        setState(() => result = '‚ö†Ô∏è Donn√©es cryptographiques incompl√®tes');
      }
    } catch (e) {
      //Gestion des erreurs lib√®res l‚Äô√©tat et arr√™tes le chargement m√™me en cas d‚Äôerreur.
      setState(() => result = '‚ùå Erreur : $e');
    } finally {
      setState(() => isLoading = false);
    }
  }

  // üìò Fonction pour valider le montant (doit √™tre un nombre valide)
  bool _isValidAmount(String amount) {
    // V√©rifie que le montant contient uniquement des chiffres et un s√©parateur d√©cimal
    final regex = RegExp(r'^\d+(\.\d{1,2})?$');
    return regex.hasMatch(amount);
  }

  String safeEncrypt(String? data) {
    if (data == null || data.isEmpty) {
      print('‚ö†Ô∏è Donn√©e vide, pas de chiffrement appliqu√©.');
      return '';
    }
    return encryptData(data);
  }

  // üìò Fonction pour valider les donn√©es avant de les crypter/d√©chiffrer
  String? validateData(String data) {
    if (data.isEmpty) {
      print(
        '‚ùå Donn√©es vides, impossible de proc√©der avec le chiffrement/d√©chiffrement',
      );
      return null; // Si les donn√©es sont vides, retourner null
    }
    return data; // Retourne les donn√©es si elles sont valides
  }

  // üìò Fonction pour d√©coder les erreurs APDU

  /*Cette fonction sert √† interpr√©ter le code retour des commandes APDU envoy√©es √† la carte (r√©ponse de la carte).
  En EMV, chaque r√©ponse APDU se termine par un code status word (SW) de 2 octets (souvent 9000, 6A88, etc.). */
  String decodeApduError(String apduResponse) {
    final errorCode = apduResponse.substring(
      apduResponse.length - 4,
    ); //prends les 4 derniers caract√®res de la r√©ponse hexad√©cimale, car le status word est toujours √† la fin.
    final errorCodes = {
      //C‚Äôest une table de correspondance entre le code et son message explicatif.
      '6A88': 'S√©lecteur d‚Äôapplication non trouv√©',
      '6F': 'Erreur g√©n√©rique',
      '9000': 'Succ√®s',
      '6700': 'Param√®tre incorrect',
      '6982': 'Conditions d‚Äôutilisation non remplies',
      // Ajouter plus de codes d'erreurs EMV ici
    };

    return errorCodes[errorCode] ??
        'Erreur inconnue : $errorCode'; //Si le code existe dans ton dictionnaire : il retourne le message.Sinon : il affiche "Erreur inconnue : <le code>".
  }

  void resetFields() {
    //R√©initialiser tous les champs de ta transaction avant d‚Äôen d√©marrer une nouvelle
    setState(() {
      pan = '';
      expiration = '';
      name = '';
      ac = '';
      atc = '';
      cid = '';
      result = '';
      isLoading = false;
      amount = ''; // R√©initialisation du montant
      amountController.clear(); // R√©initialisation du champ de saisie
    });
  }

  List<int> _hexToBytes(String hex) {
    //Convertir une cha√Æne hexad√©cimale en liste d‚Äôoctets (List<int>).
    hex =
        hex
            .replaceAll(' ', '')
            .toUpperCase(); //Nettoie la cha√Æne (replaceAll(' ', ''), toUpperCase()).
    return [
      for (var i = 0; i < hex.length; i += 2)
        int.parse(
          hex.substring(i, i + 2),
          radix: 16,
        ), //D√©coupe par paires de caract√®res (2 par 2).Chaque paire est convertie en entier base 16.
    ];
  }

  Map<String, String> extractCardData(List<TLV> tlvs) {
    // R√©cup√©rer les donn√©es de la carte bancaire (PAN, expiration, nom)
    Map<String, String> cardData = {};

    for (final tlv in tlvs) {
      // Recherche des donn√©es int√©ressantes
      if (tlv.tag == 0x5A) {
        // PAN (num√©ro de la carte)
        cardData['pan'] =
            tlv.value.map((b) => b.toRadixString(16).padLeft(2, '0')).join();
      } else if (tlv.tag == 0x5F24) {
        // Expiration (format YYMMDD)
        final date =
            tlv.value.map((b) => b.toRadixString(16).padLeft(2, '0')).join();
        cardData['expiration'] =
            '20${date.substring(0, 2)}/${date.substring(2, 4)}';
      } else if (tlv.tag == 0x5F20) {
        // Nom du titulaire
        cardData['name'] = String.fromCharCodes(tlv.value);
      }
    }

    return cardData;
  }

  Map<String, String> extractAuthData(List<TLV> tlvs) {
    // Extraire les informations d‚Äôauthentification cryptographique de la carte
    // Ce sont les √©l√©ments cryptographiques utilis√©s pour la s√©curit√© EMV
    Map<String, String> authData = {};

    for (final tlv in tlvs) {
      if (tlv.tag == 0x9F26) {
        // AC (Application Cryptogram)
        authData['ac'] = Hex.encode(tlv.value);
      } else if (tlv.tag == 0x9F36) {
        // ATC (Application Transaction Counter)
        authData['atc'] = Hex.encode(tlv.value);
      } else if (tlv.tag == 0x9F27) {
        // CID (Cryptogram Information Data)
        authData['cid'] = Hex.encode(tlv.value);
      }
    }

    return authData;
  }

  String encryptData(String data) {
    //Chiffre les donn√©es sensibles avec AES.
    final validatedData = validateData(data);
    if (validatedData == null) return '';
    final encrypter = encrypt.Encrypter(encrypt.AES(aesKey));
    final encrypted = encrypter.encrypt(validatedData, iv: aesIv);
    return encrypted.base64;
  }

  String decryptData(String encryptedData) {
    //D√©chiffre les donn√©es pour pouvoir les relire.
    if (encryptedData.isEmpty) return '';
    final encryptedBytes = encrypt.Encrypted.fromBase64(encryptedData);
    final encrypter = encrypt.Encrypter(encrypt.AES(aesKey));
    final decrypted = encrypter.decrypt(encryptedBytes, iv: aesIv);
    return decrypted;
  }
  /*Utilise la librairie encrypt avec une cl√© AES (aesKey) et un vecteur d'initialisation (IV) (aesIv).
  S√©curise des infos comme ac, atc, cid stock√©es dans le t√©l√©phone. */

  bool _terminalRiskManagement(String cardCountryCode) {
    //Effectuer la gestion du risque c√¥t√© terminal (TRM ‚Üí Terminal Risk Management). Elle d√©cide si la transaction peut rester offline ou doit passer online.
    try {
      final montant = (double.tryParse(amount) ?? 0) * 100; // en centimes

      if (montant <= 0) {
        //Refuser : montant invalide
        result = '‚ùå Montant invalide';
        return false;
      }

      // üí∞ V√©rification du montant
      if (montant > floorLimit) {
        //Forcer autorisation online
        result =
            '‚ÑπÔ∏è Montant d√©passe le seuil offline ‚Üí Forcer autorisation en ligne';
        return false; // online required
      }

      // üó∫Ô∏è V√©rification du pays
      const terminalCountryCode = '0012'; // Ex. 056 pour l‚ÄôAlg√©rie
      if (cardCountryCode != terminalCountryCode) {
        //Forcer online
        result = 'üåç Carte d‚Äôun autre pays ‚Üí Autorisation en ligne requise';
        return false;
      }

      // üö´ V√©rification blacklist (exemple simple avec PAN bloqu√©s)
      const blacklistedPans = [
        '4111111111111111',
        '5500000000000004',
      ]; //Refuser
      if (blacklistedPans.contains(
        pan.replaceAll('-', '').replaceAll(' ', ''),
      )) {
        result = 'üö´ Carte sur blacklist ‚Üí Transaction refus√©e';
        return false;
      }

      // üïê Exemple de velocity check (√† am√©liorer selon ton besoin)
      const maxOfflineTransactions = 3;
      final offlineCount =
          transactionLogs.where((t) => t.status.contains('offline')).length;

      if (offlineCount >= maxOfflineTransactions) {
        //Forcer online
        result =
            'üîÅ Trop de transactions offline ‚Üí Autorisation en ligne requise';
        return false;
      }

      result = '‚úÖ Transaction accept√©e offline';
      return true; // OK offline
    } catch (e) {
      result = '‚ùå Erreur TRM : $e';
      return false;
    }
  }

  void _loadTransactions() async {
    //Charger l‚Äôhistorique des transactions stock√©es localement (sur le t√©l√©phone).
    final saved =
        await TransactionStorage.loadTransactions(); //Lit les transactions enregistr√©es cette fonction ce trouve dans transaction_storage.dart Elle appelle la m√©thode de chargement.C‚Äôest asynchrone ‚Üí donc elle attend que la lecture soit finie.
    setState(() {
      // Une fois les donn√©es charg√©es, elle met √† jour la variable transactionLogs avec la liste r√©cup√©r√©e.
      transactionLogs = saved;
    });
  }

  Future<void> _initializeCrypto() async {
    aesKey = await SecureStorageHelper.getOrCreateKey();
    aesIv = await SecureStorageHelper.getOrCreateIv();
  }

  /// Initialise la cl√© AES et l‚ÄôIV en les r√©cup√©rant depuis le stockage s√©curis√©.
  /// Si jamais ils n‚Äôexistent pas ‚Üí les g√©n√®re automatiquement.

  @override
  void initState() {
    super.initState();
    _initializeCrypto(); //Initialise la cl√© AES et l‚ÄôIV s√©curis√©s d√®s le d√©marrage.
    _loadTransactions(); //d√®s que ta page est ouverte, l‚Äôhistorique est automatiquement charg√©.

    // Si un montant initial est fourni ‚Üí pr√©-remplit le champ et lance la transaction automatiquement.
    if (widget.initialAmount != null && widget.initialAmount!.isNotEmpty) {
      amount = widget.initialAmount!;
      amountController.text = widget.initialAmount!;

      WidgetsBinding.instance.addPostFrameCallback((_) {
        FocusScope.of(context).unfocus();
        _startEMVSession(skipReset: true);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('SoftPOS - EMV NFC'),
        centerTitle: true,
        backgroundColor: Colors.black,
        elevation: 4,
        actions: [
          IconButton(
            icon: const Icon(Icons.delete_forever),
            tooltip: 'Effacer l‚Äôhistorique',
            onPressed: () async {
              await TransactionStorage.clearTransactions();
              setState(() {
                transactionLogs.clear();
                result = 'üóëÔ∏è Historique effac√©';
              });
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            widget.initialAmount == null || widget.initialAmount!.isEmpty
                ? Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'üí∞ Montant √† encaisser',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    TextField(
                      controller: amountController,
                      keyboardType: const TextInputType.numberWithOptions(
                        decimal: true,
                      ),
                      decoration: InputDecoration(
                        hintText: 'Ex : 1500.00',
                        prefixIcon: const Icon(Icons.payments),
                        filled: true,
                        fillColor: Colors.grey[200],
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                        ),
                      ),
                      onChanged: (value) => setState(() => amount = value),
                    ),
                  ],
                )
                : Text(
                  'üí∞ Montant : \$$amount',
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.w500,
                  ),
                ),

            const SizedBox(height: 24),
            Row(
              children: [
                const SizedBox(width: 12),
                OutlinedButton.icon(
                  onPressed: () {
                    Navigator.pushAndRemoveUntil(
                      context,
                      MaterialPageRoute(builder: (_) => const MainNavigation()),
                      (route) => false,
                    );
                  },
                  icon: const Icon(Icons.home),
                  label: const Text('Accueil'),
                  style: OutlinedButton.styleFrom(
                    side: const BorderSide(color: Colors.teal),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(10),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 30),
            if (isLoading)
              const Center(child: CircularProgressIndicator())
            else ...[
              Text('üí≥ PAN : $pan', style: const TextStyle(fontSize: 16)),
              Text('üìÖ Expiration : $expiration'),
              Text('üë§ Nom : $name'),
              const Divider(thickness: 1.2),
              Text('üîê AC : ${decryptData(ac)}'),
              Text('üî¢ ATC : ${decryptData(atc)}'),
              Text('üìÑ CID : ${decryptData(cid)}'),
              const SizedBox(height: 10),
              Text(result, style: const TextStyle(fontWeight: FontWeight.w500)),
            ],
          ],
        ),
      ),
    );
  }
}
